/*
 *  EMAFilterTest.cpp
 *
 *  Generates a square wave with 4 frequencies or noise and prints filtered values
 *
 *  Copyright (C) 2020-2023  Armin Joachimsmeyer
 *  Email: armin.joachimsmeyer@gmail.com
 *
 *  This file is part of Arduino-Utils https://github.com/ArminJo/Arduino-Utils.
 *
 *  Arduino-Utils is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.
 *
 */

#include <Arduino.h>

#define MEASURE_TIMING
//#define TIMING_OUT_PIN  12
#include "SimpleEMAFilters.hpp"

#define INPUT_WAVEFORM_RECTANGLE    0
#define INPUT_WAVEFORM_SINE         1
#define INPUT_WAVEFORM_TRIANGLE     2
#define INPUT_WAVEFORM_SAWTOOTH     3
#define INPUT_WAVEFORM_RANDOM       4
#define REPEATS_FOR_WAVEFORM_RANDOM 1
#define INPUT_WAVEFORM_MAX          INPUT_WAVEFORM_RANDOM

#define INPUT_PERIOD_SAMPLES_START 24 // Start the signal generation with 25 samples per period to see sines generated by double and triple filters. Should be even.
#define INPUT_PERIOD_PER_FREQUENCY 2 // Number of complete periods per fixed frequency.

// Adjust to see behavior for small values
#define MAXIMUM_INPUT_VALUE 100      // Here the 3 lines for filter5 are almost identical - picture 1, 3, 4 in readme
//#define MAXIMUM_INPUT_VALUE 16385L // Here we get overflows for square wave at `InputValue - Lowpass3` while changing sign
//#define MAXIMUM_INPUT_VALUE 16384L // Here we get overflows for square wave at `InputValue - Lowpass3` while changing from - to + value
//#define MAXIMUM_INPUT_VALUE 16383L // The maximum value without overflows for square wave and fast 16 bit filters
//#define MAXIMUM_INPUT_VALUE 20     // here we see clipping effects due to the limited resolution of the used 16 bit math - picture 2 in readme

void setup() {

    pinMode(4, INPUT_PULLUP);
    pinMode(5, INPUT_PULLUP);
    pinMode(6, INPUT_PULLUP);
    pinMode(7, INPUT_PULLUP);
    pinMode(8, INPUT_PULLUP);
    pinMode(9, INPUT_PULLUP);

    Serial.begin(115200);
#if defined(__AVR_ATmega32U4__) || defined(SERIAL_PORT_USBVIRTUAL) || defined(SERIAL_USB) /*stm32duino*/|| defined(USBCON) /*STM32_stm32*/ \
    || defined(SERIALUSB_PID)  || defined(ARDUINO_ARCH_RP2040) || defined(ARDUINO_attiny3217)
    delay(4000); // To be able to connect Serial monitor after reset or power up and before first print out. Do not wait for an attached Serial Monitor!
#endif

//    Serial.println(F("START " __FILE__ "\r\nUsing library version " VERSION_SIMPLE_EMA_FILTERS " from " __DATE__));

}

uint8_t ReadFilterSelectionBCDValueFromPins() {
    /*
     * Read BCD values at pin 4,5,6 into variable
     */
    uint8_t tSelection = 0;
    if (digitalRead(4) == LOW) {
        tSelection += 1;
    }
    if (digitalRead(5) == LOW) {
        tSelection += 2;
    }
    if (digitalRead(6) == LOW) {
        tSelection += 4;
    }
    return tSelection;
}

uint8_t ReadInputWaveformSelectionBCDValueFromPins() {
    /*
     * Read BCD values at pin 7,8 into variable
     */
    uint8_t tSelection = 0;
    if (digitalRead(7) == LOW) {
        tSelection += 1;
    }
    if (digitalRead(8) == LOW) {
        tSelection += 2;
    }
    if (digitalRead(9) == LOW) {
        tSelection += 4;
    }
    if (tSelection > INPUT_WAVEFORM_MAX) {
        tSelection = INPUT_WAVEFORM_RECTANGLE;
    }
    return tSelection;
}

uint8_t sOldFilterSelection = 42;
uint8_t sOldInputWaveformSelection = 42;

uint16_t sLoopCount;    // 0 (1 for first loop) to 499
uint8_t sPeriodCount;       // 0 to 4
uint8_t sSamplesPerPeriod;  // 0 to INPUT_PERIOD_SAMPLES_START (200)
uint8_t sSampleCount;       // 0 to INPUT_PERIOD_SAMPLES_START (200)
int16_t sInput;

/*
 * Create a signal starting with a period of 24, which is equivalent to a frequency of 42 Hz for a 1 kHz sampling frequency.
 * Next frequency is half the preceding one.
 * 42 Hz > 21 Hz > 10.5 Hz > 5.2 Hz
 * Except for random :-)
 */
void loop() {
    /*
     * Read BCD values at pin 4,5,6 into variable
     */
    uint8_t tFilterSelection = ReadFilterSelectionBCDValueFromPins();
    if (sOldFilterSelection != tFilterSelection) {
        if (sOldFilterSelection == 42) {
            sLoopCount = 1;
        } else {
            sLoopCount = 0;
        }
        sOldFilterSelection = tFilterSelection;

        // Print caption for Arduino Plotter
        printFiltersCaption(tFilterSelection);
        resetFilters();
        sPeriodCount = 0;
        sSamplesPerPeriod = INPUT_PERIOD_SAMPLES_START;
        sSampleCount = 0;
    }

    uint8_t tInputWaveformSelection = ReadInputWaveformSelectionBCDValueFromPins();
    if (sOldInputWaveformSelection != tInputWaveformSelection) {
        if (sOldInputWaveformSelection == 42) {
            sLoopCount = 1;
        } else {
            sLoopCount = 0;
        }
        sOldInputWaveformSelection = tInputWaveformSelection;
        // Print caption for Arduino Plotter
        printFiltersCaption(tFilterSelection);
        resetFilters();
        sPeriodCount = 0;
        sSamplesPerPeriod = INPUT_PERIOD_SAMPLES_START;
        sSampleCount = 0;
    }

    // Caption (without values) is not shown as graph, but counted as output for X axes :-(
    while (sLoopCount < 500) {

        /*
         * Input signal generation
         */
        if (tInputWaveformSelection == INPUT_WAVEFORM_RECTANGLE) {
            if (sSampleCount < sSamplesPerPeriod / 2) {
                sInput = MAXIMUM_INPUT_VALUE;
            } else {
                sInput = -MAXIMUM_INPUT_VALUE;
            }

        } else if (tInputWaveformSelection == INPUT_WAVEFORM_SINE) {
            sInput = MAXIMUM_INPUT_VALUE * sin(((float) sSampleCount * TWO_PI) / sSamplesPerPeriod);

        } else if (tInputWaveformSelection == INPUT_WAVEFORM_TRIANGLE) {
            int16_t tInput = sSampleCount % (sSamplesPerPeriod / 4);
            tInput = ((MAXIMUM_INPUT_VALUE * tInput) / (sSamplesPerPeriod / 4)); // e.g 400 * x / 6

            if (sSampleCount < sSamplesPerPeriod / 4) {
                // First quarter (e.g. 0 to 5)
                sInput = tInput;

            } else if (sSampleCount < sSamplesPerPeriod / 2) {
                // Second quarter (e.g. 6 to 11)
                sInput = MAXIMUM_INPUT_VALUE - tInput;

            } else if (sSampleCount < (sSamplesPerPeriod / 2 + sSamplesPerPeriod / 4)) {
                // third quarter (e.g. 12 to 17)
                sInput = -tInput;

            } else {
                // forth quarter (e.g. 18 to 23)
                sInput = tInput - MAXIMUM_INPUT_VALUE;
            }

        } else if (tInputWaveformSelection == INPUT_WAVEFORM_SAWTOOTH) {
            int16_t tInput = sSampleCount % (sSamplesPerPeriod / 2);
            tInput = ((MAXIMUM_INPUT_VALUE * (uint16_t) tInput) / (sSamplesPerPeriod / 2));
            if (sSampleCount < sSamplesPerPeriod / 2) {
                sInput = tInput;
            } else {
                sInput = tInput - MAXIMUM_INPUT_VALUE;
            }

        } else {
            // Random
            sInput = random(MAXIMUM_INPUT_VALUE);
        }

        /*
         * Running filters and changing periods
         */
        doFiltersStep(sInput);
        sSampleCount++;
        if (sSampleCount >= sSamplesPerPeriod) {
            sSampleCount = 0;
            sPeriodCount++;
            if (sPeriodCount >= 2) {
                sPeriodCount = 0;
                sSamplesPerPeriod += sSamplesPerPeriod;
            }
        }

        printFiltersResults(FilterSelectionArray[tFilterSelection]);
        sLoopCount++; // Stop output after 500 prints

        if (tInputWaveformSelection == INPUT_WAVEFORM_RANDOM) {
            // print every value additionally n times to make results more visible
            for (int i = 0; i < REPEATS_FOR_WAVEFORM_RANDOM; ++i) {
                printFiltersResults(FilterSelectionArray[tFilterSelection]);
                sLoopCount++;
            }
        }
    }

    delay(100);
}
